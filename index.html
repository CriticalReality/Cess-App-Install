<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cess</title>
<link rel="icon" href="favicon.ico" type="image/x-icon">
<!-- Added Manifest + Theme -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">

<!-- Added iOS Support -->
<link rel="apple-touch-icon" href="icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="Your App">
<style>
  :root{
    --board-size: 6;
    --cell-size: 64px;
    --font: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;font-family:var(--font);background:#111;color:#eee;overflow:hidden}
  body{display:flex;align-items:center;justify-content:center;position:relative}
  #boardWrap{flex:1;display:flex;align-items:center;justify-content:center;width:100%;height:100%}
  #board{
    display:grid;
    grid-template-columns: repeat(var(--board-size), var(--cell-size));
    grid-template-rows: repeat(var(--board-size), var(--cell-size));
    gap:2px;
    padding:10px;
    border-radius:12px;
    box-sizing:content-box;
    touch-action:manipulation;
    user-select:none;
    z-index:1;
  }
  .cell{
    width:var(--cell-size);height:var(--cell-size);
    display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;
    border-radius:6px;box-shadow:inset 0 -8px 14px rgba(0,0,0,0.15);
    position:relative;
  }
  .label{position:absolute;left:6px;top:6px;font-size:11px;opacity:0.6}
  .piece{width:90%;height:90%;display:flex;align-items:center;justify-content:center;border-radius:6px;font-size:18px;cursor:pointer;user-select:none}
  .selected{outline:3px solid rgba(255,255,255,0.25);box-shadow:0 6px 18px rgba(0,0,0,0.6)}
  .hint{width:30%;height:30%;border-radius:50%;opacity:0.9}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:5}
  .small{font-size:12px;opacity:0.9}
  #hud{
    position:absolute;
    top:16px;left:16px;
    background:rgba(0,0,0,0.3);
    border-radius:10px;
    padding:10px 14px;
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    font-weight:600;
    font-size:14px;
    z-index:10;
  }
  .hud-item{min-width:72px;text-align:center}
  #controls{
    position:absolute;
    bottom:20px;
    right:20px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    z-index:10;
  }
  button{padding:8px 10px;border-radius:8px;border:0;background:#222;color:#eee;cursor:pointer}
  button:active{transform:translateY(1px)}
  #message{
    position:absolute;
    bottom:70px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(0,0,0,0.3);
    padding:6px 12px;
    border-radius:8px;
    font-weight:600;
    z-index:10;
  }
  @media (max-width:880px){
    :root{--cell-size:48px}
  }
</style>
</head>
<body>
  <div id="hud">
    <div class="hud-item">Level <div id="level" class="small">1</div></div>
    <div class="hud-item">Wins <div id="wins" class="small">0</div></div>
    <div class="hud-item">Time <div id="time" class="small">00:00</div></div>
    <div class="hud-item">Seed <div id="seed" class="small">—</div></div>
  </div>

  <div id="boardWrap">
    <div id="board" class="panel" role="application" aria-label="game board"></div>
  </div>

  <div id="message" class="small"></div>

  <div id="controls">
    <button id="btnRestart">Restart Level</button>
    <button id="btnNextSim" title="Skip AI moves (fast-forward)">Simulate Move</button>
    <button id="btnNewSeed">New Seed</button>
    
  </div>
  <h1>Your PWA is running</h1>

<script>//addedthefolloing
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js')
    .then(() => console.log('Service Worker registered'))
    .catch(err => console.error('SW failed', err));
}
</script>
</body>
</html>
<script>
/*
 Procedural Expanding Timed Chess
 - Single-file implementation
 - Tap to select a piece, tap destination to move
 - Simple legal move generation (standard piece moves)
 - Enemy makes a simple random legal move after the player
 - Levels start smaller (e.g., 5x5) with few pieces, grow each win.
 - Color theme generated from seed (deterministic)
 - Continues increasing board size past 8x8 indefinitely
*/

/////////////////// Utilities: seeded RNG + helpers ///////////////////

class RNG {
  constructor(seed) {
    this.seed = this.hashSeed(String(seed));
  }
  hashSeed(s){
    let h = 2166136261 >>> 0;
    for (let i=0;i<s.length;i++){
      h = Math.imul(h ^ s.charCodeAt(i), 16777619) >>> 0;
    }
    return h || 1;
  }
  next(){
    // xorshift32
    let x = this.seed;
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    this.seed = x >>> 0;
    return this.seed / 0xFFFFFFFF;
  }
  int(min, max){ return Math.floor(this.next()*(max-min+1))+min; }
  pick(arr){ return arr[Math.floor(this.next()*arr.length)]; }
}

function coordKey(x,y){return `${x},${y}`;}
function inBounds(x,y,n){return x>=0 && y>=0 && x<n && y<n;}

/////////////////// Chess representation ///////////////////

const PIECE_CHARS = {
  pawn: 'p', rook:'r', knight:'n', bishop:'b', queen:'q', king:'k'
};
const DIRS = {
  knight:[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]],
  bishop:[[1,1],[1,-1],[-1,1],[-1,-1]],
  rook:[[1,0],[-1,0],[0,1],[0,-1]],
  queen:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]],
};

function createPiece(type,color){ return {t:type,c:color,id: Math.random().toString(36).slice(2,9)}; }

/////////////////// Game State ///////////////////

let state = {
  level: 1,
  wins: 0,
  boardSize: 6,
  board: new Map(), // key -> piece
  turn: 'player', // 'player' or 'enemy'
  selected: null,
  rng: new RNG('default'),
  seed: 'default',
  timeLeft: 60,
  timerInterval: null,
  levelStartTime: 60,
  paused: false,
  status: 'ready' // ready, running, win, lose
};

const ui = {
  boardEl: document.getElementById('board'),
  levelEl: document.getElementById('level'),
  winsEl: document.getElementById('wins'),
  timeEl: document.getElementById('time'),
  seedEl: document.getElementById('seed'),
  messageEl: document.getElementById('message'),
  debugEl: document.getElementById('debug'),
  btnRestart: document.getElementById('btnRestart'),
  btnNextSim: document.getElementById('btnNextSim'),
  btnNewSeed: document.getElementById('btnNewSeed'),
  btnExport: document.getElementById('btnExport')
};

/////////////////// Theme generation ///////////////////

function generateTheme(seed){
  const rng = new RNG(seed);
  // generate two base hues and contrasts
  const h1 = Math.floor(rng.next()*360);
  const h2 = (h1 + rng.int(60,200)) % 360;
  const bgL = rng.int(6,14); // lightness of page background adjustments
  const cellBase = `hsl(${h1} ${rng.int(35,55)}% ${rng.int(18,28)}%)`;
  const cellAlt  = `hsl(${h2} ${rng.int(30,60)}% ${rng.int(20,32)}%)`;
  const pieceLight = `hsl(${h2} ${rng.int(35,65)}% ${rng.int(72,88)}%)`;
  const pieceDark = `hsl(${h1} ${rng.int(35,65)}% ${rng.int(72,88)}%)`;
  const accent = `hsl(${rng.int(0,360)} ${rng.int(55,80)}% ${rng.int(45,60)}%)`;
  return {cellBase,cellAlt,pieceLight,pieceDark,accent, bgL};
}

function applyTheme(theme){
  // apply to board container background, cells etc via CSS variables on board
  ui.boardEl.style.background = `linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06))`;
  // we will set cell colors when rendering each cell
  document.body.style.background = `hsl(210 14% ${Math.max(6, 10 - theme.bgL)}%)`;
  // store for render
  state.theme = theme;
}

/////////////////// Level generation ///////////////////

function computeBoardSizeForLevel(level){
  // start small and grow faster after certain milestones
  // Level 1 -> 5x5, Level 3 -> 6x6, Level 7 -> 8x8, later grows linearly
  const base = Math.min(5 + Math.floor(level/2), 18); // cap optionally high
  return Math.max(3, base);
}

function pieceCountForLevel(level, n){
  // number of enemy pieces based on level and board area
  const area = n*n;
  const base = Math.min(3 + Math.floor(level*0.8), Math.floor(area*0.35));
  return Math.max(1, base);
}

function setupLevel(seedOverride){
  // set seed and rng
  const seed = seedOverride ?? `${Date.now()}_${state.level}`;
  state.seed = seed;
  state.rng = new RNG(seed);
  ui.seedEl.textContent = seed.slice(0,12);
  const theme = generateTheme(seed);
  applyTheme(theme);

  // compute board size and create empty board
  state.boardSize = computeBoardSizeForLevel(state.level);
  state.board = new Map();
  ui.boardEl.style.setProperty('--board-size', state.boardSize);
  // compute time limit (base time: larger boards get more time but difficulty rises)
  state.levelStartTime = Math.max(20, Math.floor(12 + state.boardSize*5 - state.level*0.4));
  state.timeLeft = state.levelStartTime;
  state.status = 'running';
  state.turn = 'player';
  state.selected = null;

  // place player pieces (bottom rows) - start with few pieces
  const n = state.boardSize;
  const rng = state.rng;
  const playerStartRow = n - 1;
  // player gets a king plus some random few pieces (based on level)
  const playerPieces = ['king','rook','knight','bishop','queen','pawn'];
  const playerCount = Math.min(Math.max(2, Math.floor(1 + state.level/2)), Math.floor(n)); // ensure at least king+one
  // ensure king present
  placePiece(Math.floor(n/2), playerStartRow, createPiece('king','player'));
  // place additional unique pieces randomly near bottom
  for (let i=0;i<playerCount-1;i++){
    const t = rng.pick(playerPieces);
    let attempts=0;
    while(attempts<200){
      const x = rng.int(0,n-1), y = rng.int(Math.max(0,n-2), n-1);
      if (!state.board.has(coordKey(x,y))){
        placePiece(x,y, createPiece(t,'player'));
        break;
      }
      attempts++;
    }
  }

  // place enemy pieces (top rows)
  const enemyCount = pieceCountForLevel(state.level, n);
  const enemyPieces = ['king','rook','knight','bishop','queen','pawn'];
  for (let i=0;i<enemyCount;i++){
    let attempts=0;
    while(attempts<400){
      const x = rng.int(0,n-1);
      const y = rng.int(0, Math.min(1, Math.floor(n/3)));
      if (!state.board.has(coordKey(x,y))){
        const t = rng.pick(enemyPieces);
        placePiece(x,y, createPiece(t,'enemy'));
        break;
      }
      attempts++;
    }
  }

  // small random scattering of additional enemy pawns across top half for bigger levels
  if (n>8){
    for (let i=0;i<Math.floor(n/2);i++){
      if (rng.next() > 0.6) continue;
      const x = rng.int(0,n-1), y = rng.int(0, Math.max(0, Math.floor(n/2)-1));
      if (!state.board.has(coordKey(x,y))){
        placePiece(x,y, createPiece('pawn','enemy'));
      }
    }
  }

  renderBoard();
  resetTimer();
  ui.levelEl.textContent = state.level;
  ui.winsEl.textContent = state.wins;
  ui.messageEl.textContent = `Capture all enemy pieces. Time: ${formatTime(state.timeLeft)}.`;
  updateDebug();
}

function placePiece(x,y,piece){
  state.board.set(coordKey(x,y), piece);
}

function clearBoardDOM(){ ui.boardEl.innerHTML = ''; }

/////////////////// Rendering ///////////////////

function renderBoard(){
  clearBoardDOM();
  const n = state.boardSize;
  ui.boardEl.style.gridTemplateColumns = `repeat(${n}, ${getCellSize()} )`;
  ui.boardEl.style.gridTemplateRows = `repeat(${n}, ${getCellSize()} )`;
  // create cells
  for (let y=0;y<n;y++){
    for (let x=0;x<n;x++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x; cell.dataset.y = y;
      cell.style.background = ((x+y)%2===0) ? state.theme.cellBase : state.theme.cellAlt;
      cell.style.width = getCellSize(); cell.style.height = getCellSize();
      const label = document.createElement('div'); label.className = 'label small'; label.textContent = `${String.fromCharCode(97+x)}${n-y}`;
      cell.appendChild(label);
      // if piece exists
      const p = state.board.get(coordKey(x,y));
      if (p){
        const pieceEl = document.createElement('div');
        pieceEl.className = 'piece';
        pieceEl.dataset.id = p.id;
        pieceEl.dataset.x = x; pieceEl.dataset.y = y;
        pieceEl.textContent = pieceSymbol(p);
        pieceEl.title = `${p.t} (${p.c})`;
        // color by side
        if (p.c === 'player'){
          pieceEl.style.background = state.theme.pieceLight;
          pieceEl.style.color = '#000';
        } else {
          pieceEl.style.background = state.theme.pieceDark;
          pieceEl.style.color = '#000';
        }
        cell.appendChild(pieceEl);
      }
      // click handling
      cell.addEventListener('pointerdown', onCellPointerDown);
      ui.boardEl.appendChild(cell);
    }
  }
  refreshSelectionHighlights();
}

function getCellSize(){
  // determine CSS size string based on --cell-size and viewport
  const cs = getComputedStyle(document.documentElement).getPropertyValue('--cell-size').trim();
  return cs || '64px';
}

function pieceSymbol(p){
  // simple text symbols (not full unicode chess for flexibility)
  const map = {pawn:'♟',rook:'♜',knight:'♞',bishop:'♝',queen:'♛',king:'♚'};
  return map[p.t] || p.t[0].toUpperCase();
}

/////////////////// Input Handling ///////////////////

function onCellPointerDown(e){
  if (state.status !== 'running') return;
  const cell = e.currentTarget;
  const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
  const key = coordKey(x,y);
  const piece = state.board.get(key);
  if (state.turn !== 'player') return;
  if (piece && piece.c === 'player'){
    state.selected = {x,y,p:piece};
    refreshSelectionHighlights();
    return;
  }
  if (state.selected){
    // attempt move from selected to (x,y)
    const move = {from:{x:state.selected.x,y:state.selected.y}, to:{x,y}};
    attemptPlayerMove(move);
  }
}

function refreshSelectionHighlights(){
  // highlight selected and legal moves
  const n = state.boardSize;
  const cells = ui.boardEl.querySelectorAll('.cell');
  cells.forEach(c=>{ c.classList.remove('selected'); const hint = c.querySelector('.hint'); if(hint) hint.remove();});
  if (!state.selected) return;
  const sx = state.selected.x, sy = state.selected.y;
  const startCell = ui.boardEl.querySelector(`.cell[data-x="${sx}"][data-y="${sy}"]`);
  if (startCell) startCell.classList.add('selected');
  const moves = generateLegalMovesForPiece(state.selected.p, sx, sy, state.board, n, 'player', true);
  for (const mv of moves){
    const target = ui.boardEl.querySelector(`.cell[data-x="${mv.x}"][data-y="${mv.y}"]`);
    if (target){
      const dot = document.createElement('div'); dot.className='hint';
      dot.style.background = (mv.capture)? state.theme.accent : 'rgba(255,255,255,0.12)';
      dot.style.margin = 'auto';
      target.appendChild(dot);
    }
  }
}

/////////////////// Move generation ///////////////////

function generateLegalMovesForPiece(piece, x, y, boardMap, n, side, forHighlight=false){
  // returns array of {x,y,capture}
  const moves = [];
  const keyAt = (xx,yy) => boardMap.get(coordKey(xx,yy));
  const ally = (p) => p && p.c === side;
  const enemy = (p) => p && p.c !== side;
  if (!piece) return moves;
  const t = piece.t;
  if (t === 'pawn'){
    // pawn direction: player -> up (-y), enemy -> down (+y)
    const dir = piece.c === 'player' ? -1 : 1;
    // forward
    const fx = x, fy = y + dir;
    if (inBounds(fx,fy,n) && !keyAt(fx,fy)) moves.push({x:fx,y:fy,capture:false});
    // captures
    for (let dx of [-1,1]){
      const cx = x+dx, cy = y+dir;
      if (inBounds(cx,cy,n)){
        const p = keyAt(cx,cy);
        if (p && p.c !== piece.c) moves.push({x:cx,y:cy,capture:true});
      }
    }
    // promotion handled on landing
  } else if (t === 'knight'){
    for (const d of DIRS.knight){
      const nx = x+d[0], ny = y+d[1];
      if (!inBounds(nx,ny,n)) continue;
      const p = keyAt(nx,ny);
      if (!ally(p)) moves.push({x:nx,y:ny,capture: !!p});
    }
  } else if (t === 'bishop' || t === 'rook' || t === 'queen'){
    const dirs = (t==='bishop')?DIRS.bishop:(t==='rook')?DIRS.rook:DIRS.queen;
    for (const d of dirs){
      let nx = x+d[0], ny = y+d[1];
      while(inBounds(nx,ny,n)){
        const p = keyAt(nx,ny);
        if (!p) moves.push({x:nx,y:ny,capture:false});
        else {
          if (!ally(p)) moves.push({x:nx,y:ny,capture:true});
          break;
        }
        nx += d[0]; ny += d[1];
      }
    }
  } else if (t === 'king'){
    for (const d of [...DIRS.queen]){
      const nx = x + d[0], ny = y + d[1];
      if (!inBounds(nx,ny,n)) continue;
      const p = keyAt(nx,ny);
      if (!ally(p)) moves.push({x:nx,y:ny,capture:!!p});
    }
  }
  // Optionally filter out moves that would leave king in check — omitted for simplicity/performance.
  return moves;
}

function allPieces(side){
  const arr = [];
  for (const [key,p] of state.board){
    if (p.c === side) {
      const [x,y] = key.split(',').map(Number);
      arr.push({x,y,p});
    }
  }
  return arr;
}

/////////////////// Move execution and turn flow ///////////////////

function attemptPlayerMove(move){
  // validate move
  const n = state.boardSize;
  const fromKey = coordKey(move.from.x, move.from.y);
  const piece = state.board.get(fromKey);
  if (!piece || piece.c !== 'player') return;
  const legal = generateLegalMovesForPiece(piece, move.from.x, move.from.y, state.board, n, 'player');
  if (!legal.some(m => m.x===move.to.x && m.y===move.to.y)) {
    ui.messageEl.textContent = 'Illegal move';
    return;
  }
  makeMove(fromKey, coordKey(move.to.x, move.to.y));
  // after player move check victory
  if (checkWinCondition()){
    handleWin();
    return;
  }
  state.turn = 'enemy';
  state.selected = null;
  renderBoard();
  // small delay then enemy moves
  setTimeout(enemyTurn, 350);
}

function makeMove(fromKey, toKey){
  const piece = state.board.get(fromKey);
  if (!piece) return;
  // capture if present
  const captured = state.board.get(toKey);
  state.board.delete(fromKey);
  state.board.set(toKey, piece);
  // handle pawn promotion: if pawn reaches far rank -> queen
  const [tx,ty] = toKey.split(',').map(Number);
  if (piece.t === 'pawn'){
    if ((piece.c === 'player' && ty === 0) || (piece.c === 'enemy' && ty === state.boardSize-1)){
      piece.t = 'queen';
    }
  }
  ui.messageEl.textContent = captured ? `Captured ${captured.t}` : 'Moved';
  renderBoard();
}

function enemyTurn(){
  if (state.status !== 'running') return;
  const n = state.boardSize;
  const pieces = allPieces('enemy');
  // gather all legal moves
  const allMoves = [];
  for (const item of pieces){
    const moves = generateLegalMovesForPiece(item.p, item.x, item.y, state.board, n, 'enemy');
    for (const m of moves){
      allMoves.push({
        from:{x:item.x,y:item.y},
        to:{x:m.x,y:m.y},
        score: m.capture ? 2 : 1
      });
    }
  }
  if (allMoves.length === 0){
    // enemy cannot move -> do nothing -> player turn
    state.turn = 'player';
    ui.messageEl.textContent = 'Enemy has no moves';
    return;
  }
  // prefer captures
  allMoves.sort((a,b)=>b.score-a.score);
  // pick among top moves
  const topScore = allMoves[0].score;
  const topMoves = allMoves.filter(m=>m.score===topScore);
  const chosen = state.rng.pick(topMoves);
  makeMove(coordKey(chosen.from.x, chosen.from.y), coordKey(chosen.to.x, chosen.to.y));
  // after enemy move, check if they captured player's last piece or vice versa
  if (checkLossCondition()){
    handleLoss();
    return;
  }
  state.turn = 'player';
  renderBoard();
}

/////////////////// Win/Lose Conditions ///////////////////

function checkWinCondition(){
  // win when no enemy pieces remain
  for (const [k,p] of state.board){
    if (p.c === 'enemy') return false;
  }
  return true;
}

function checkLossCondition(){
  // lose when no player pieces remain or time up
  let any=false;
  for (const [k,p] of state.board){
    if (p.c === 'player') { any=true; break; }
  }
  return !any;
}

function handleWin(){
  state.status = 'win';
  state.wins++;
  ui.winsEl.textContent = state.wins;
  ui.messageEl.textContent = `Level cleared in ${formatTime(state.levelStartTime - state.timeLeft)}. Advancing.`;
  stopTimer();
  // increase level and board grows
  state.level++;
  // small pause then next level auto-start
  setTimeout(()=> setupLevel(state.seed + '_' + state.level), 600);
}

function handleLoss(){
  state.status = 'lose';
  ui.messageEl.textContent = 'You lost. Restart or retry level.';
  stopTimer();
}

/////////////////// Timer ///////////////////

function formatTime(seconds){
  const s = Math.max(0, Math.floor(seconds));
  const m = Math.floor(s/60);
  const ss = String(s%60).padStart(2,'0');
  return `${m}:${ss}`;
}

function resetTimer(){
  stopTimer();
  updateTimeUI();
  state.timerInterval = setInterval(()=>{
    if (state.status !== 'running') return;
    state.timeLeft -= 0.25; // quarter-second ticks for smoothness
    if (state.timeLeft <= 0){
      state.timeLeft = 0;
      updateTimeUI();
      handleLoss();
    } else {
      updateTimeUI();
    }
  }, 250);
}

function updateTimeUI(){
  ui.timeEl.textContent = formatTime(state.timeLeft);
  // update message with urgency
  const pct = state.timeLeft / state.levelStartTime;
  if (pct < 0.25) ui.messageEl.style.color = 'salmon';
  else ui.messageEl.style.color = '';
}

function stopTimer(){
  if (state.timerInterval) { clearInterval(state.timerInterval); state.timerInterval = null; }
}

/////////////////// Controls ///////////////////

ui.btnRestart.addEventListener('click', ()=> {
  setupLevel(state.seed); // restart with same seed and level
});

ui.btnNextSim.addEventListener('click', ()=> {
  // simulate one enemy move (if it's enemy turn)
  if (state.turn === 'enemy') enemyTurn();
  else {
    // allow skipping to enemy to test fast moves
    state.turn = 'enemy'; enemyTurn();
  }
});

ui.btnNewSeed.addEventListener('click', ()=> {
  // new random seed for same level
  const newSeed = Math.random().toString(36).slice(2,10);
  setupLevel(newSeed);
});

ui.btnExport.addEventListener('click', ()=> {
  const exportObj = {
    level: state.level,
    boardSize: state.boardSize,
    seed: state.seed,
    pieces: Array.from(state.board).map(([k,p]) => ({pos:k, t:p.t, c:p.c}))
  };
  const blob = new Blob([JSON.stringify(exportObj,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `level_${state.level}_${state.seed.slice(0,8)}.json`;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

// keyboard: space to simulate enemy quickly for testing
window.addEventListener('keydown', (e)=>{
  if (e.code === 'Space'){ e.preventDefault(); ui.btnNextSim.click(); }
});

/////////////////// Debugging ///////////////////

function updateDebug(){
  const n = state.boardSize;
  const counts = {player:0, enemy:0};
  for (const [k,p] of state.board){ counts[p.c]++; }
  ui.debugEl.textContent = `n=${n} pieces P:${counts.player} E:${counts.enemy} seed=${state.seed.slice(0,10)}`;
}

/////////////////// Initialization ///////////////////

// start at level 1 with random seed
(function init(){
  state.level = 1;
  state.wins = 0;
  setupLevel();
})();

</script>

